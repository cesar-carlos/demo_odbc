---
description: Coding Conventions - Naming, file structure and patterns (reusable)
globs: ["lib/**/*.dart"]
alwaysApply: true
---

# Coding Conventions

## Naming

### Classes and Interfaces

- **Entities**: Singular nouns, PascalCase
  - `User`, `Product`, `Order`
- **Value Objects**: Descriptive nouns, PascalCase
  - `Email`, `Money`, `CPF`, `Address`
- **Use Cases**: Infinitive verbs, PascalCase
  - `GetUserById`, `CreateProduct`, `UpdateOrder`
- **Repositories (Interfaces)**: Prefix `I` + singular name, PascalCase
  - `IUserRepository`, `IProductRepository`
- **Repositories (Implementations)**: Singular name + `Repository`, PascalCase
  - `UserRepository`, `ProductRepository`
- **Services**: Singular name + `Service`, PascalCase
  - `UserService`, `ProductService`
- **DTOs**: Singular name + `DTO`, PascalCase
  - `UserDTO`, `ProductDTO`
- **Data Sources (Interfaces)**: Prefix `I` + name + `DataSource`, PascalCase
  - `IUserDataSource`, `IRemoteDataSource`
- **Data Sources (Implementations)**: Name + type + `DataSource`, PascalCase
  - `UserRemoteDataSource`, `UserLocalDataSource`
- **Models**: Singular name + `Model`, PascalCase
  - `UserModel`, `ProductModel`
- **Controllers**: Name + `Controller`, PascalCase
  - `UserController`, `HomeController`
- **Providers**: Name + `Provider`, PascalCase
  - `UserProvider`, `ProductProvider`
- **Errors/Exceptions**: Descriptive name + `Failure` or `Exception`, PascalCase
  - `UserNotFoundFailure`, `NetworkException`, `ValidationFailure`

### Variables and Methods

- **Variables**: camelCase
  - `userName`, `productList`, `isLoading`
- **Methods**: camelCase, verbs
  - `getUser()`, `createProduct()`, `isValid()`
- **Constants**: camelCase with `const` or `static const`
  - `const maxRetries = 3`, `static const apiUrl = 'https://api.example.com'`
- **Private parameters**: Prefix `_` + camelCase
  - `_repository`, `_userService`

### Files

- **Files**: snake_case, same naming as main class
  - `user.dart` → `class User`
  - `get_user_by_id.dart` → `class GetUserById`
  - `i_user_repository.dart` → `abstract class IUserRepository`

## Use Case Structure

```dart
// domain/use_cases/get_user_by_id.dart
import 'package:result_dart/result_dart.dart';
import '../entities/user.dart';
import '../repositories/repositories.dart';
import '../errors/errors.dart';

class GetUserById {
  final IUserRepository repository;

  GetUserById(this.repository);

  Future<Result<User>> call(String id) async {
    if (id.isEmpty) {
      return Failure(ValidationFailure('ID cannot be empty'));
    }

    return await repository.getById(id);
  }
}
```

## Repository Interface

```dart
// domain/repositories/i_user_repository.dart
import 'package:result_dart/result_dart.dart';
import '../entities/user.dart';
import '../errors/errors.dart';

abstract class IUserRepository {
  Future<Result<User>> getById(String id);
  Future<Result<List<User>>> getAll();
  Future<Result<User>> create(User user);
  Future<Result<void>> update(User user);
  Future<Result<void>> delete(String id);
}
```

## Repository Implementation

```dart
// infrastructure/repositories/user_repository.dart
import 'package:result_dart/result_dart.dart';
import 'package:domain/domain.dart';
import '../datasources/datasources.dart';
import '../models/models.dart';

class UserRepository implements IUserRepository {
  final IUserDataSource remoteDataSource;
  final IUserDataSource localDataSource;

  UserRepository({
    required this.remoteDataSource,
    required this.localDataSource,
  });

  @override
  Future<Result<User>> getById(String id) async {
    try {
      final localResult = await localDataSource.getById(id);
      if (localResult != null) {
        return Success(localResult.toEntity());
      }

      final remoteResult = await remoteDataSource.getById(id);
      return Success(remoteResult.toEntity());
    } on NetworkException catch (e) {
      return Failure(NetworkFailure(e.message));
    } catch (e) {
      return Failure(ServerFailure(e.toString()));
    }
  }

  // ... other methods
}
```

## Error Handling

### Use Result Pattern (result_dart)

```dart
// domain/errors/errors.dart
abstract class Failure {
  final String message;
  Failure(this.message);
}

class ServerFailure extends Failure {
  ServerFailure(String message) : super(message);
}

class NetworkFailure extends Failure {
  NetworkFailure(String message) : super(message);
}

class ValidationFailure extends Failure {
  ValidationFailure(String message) : super(message);
}

// Usage
import 'package:result_dart/result_dart.dart';

Future<Result<User>> getUser(String id) async {
  if (id.isEmpty) {
    return Failure(ValidationFailure('ID cannot be empty'));
  }

  try {
    final result = await repository.getById(id);
    return result;
  } catch (e) {
    return Failure(ServerFailure(e.toString()));
  }
}

// Result handling
final result = await getUser('123');
result.fold(
  (success) {
    // Handle success
    print('User: ${success.name}');
  },
  (failure) {
    // Handle failure
    print('Error: ${failure.message}');
  },
);
```

## Dependency Injection

### Via Constructor

```dart
// ✅ Correct: Injection via constructor
class UserService {
  final IUserRepository repository;

  UserService(this.repository);
}

// Usage
final repository = UserRepository(/* ... */);
final service = UserService(repository);
```

### Avoid Direct Singleton

```dart
// ❌ Avoid: Direct singleton
class UserService {
  static final UserService _instance = UserService._();
  factory UserService() => _instance;
  UserService._();

  final repository = UserRepository(); // ❌ Hardcoded dependency
}
```

## Import Organization

### Import Order

1. Flutter/Dart imports
2. External packages
3. Core and Shared
4. Other layers (domain, application, etc.)
5. Relative (same layer)

### Example

```dart
// Flutter/Dart
import 'package:flutter/material.dart';
import 'dart:async';

// External packages
import 'package:http/http.dart' as http;
import 'package:get_it/get_it.dart';

// Core and Shared
import 'package:core/core.dart';
import 'package:shared/shared.dart';

// Other layers
import 'package:domain/domain.dart';
import 'package:application/application.dart';

// Relative
import '../entities/user.dart';
import '../repositories/repositories.dart';
```

## Don't Create Documentation Automatically

- ❌ **DO NOT create documentation** (`///`, `README.md`, etc.) automatically
- ❌ **DO NOT add unnecessary comments** to code
- ✅ **ONLY create documentation when explicitly requested** by user
- ✅ **Code should be self-explanatory** through clear naming

### Only Document When Requested

- ✅ Document only complex public APIs when requested
- ✅ Use `///` for public API documentation (only when necessary and explicitly requested)
- ✅ Use `//` for internal comments (only when necessary)

### Comments

- ✅ Use comments only to explain "why", not "what"
- ✅ Keep comments updated with code
- ✅ Prefer clear code over comments

```dart
// ✅ Good: explains why (important decision)
// Use local cache to reduce API calls by 80%
final cachedUser = await localCache.getUser(id);

// ❌ Avoid: explains what (code already does this)
// Get user from cache
final user = await cache.getUser(id);
```

**Note**: For more detailed documentation rules, see `general_rules.mdc`.
